/*
  주소 : 메모리 공간은 8bit인 1byte마다 고유한 address존재 /   메모리 주소는 0부터 바이트마다 1씩 증가함.
  메모리 주소는 저장 장소인 변수 이름과 함꼐 기억 장소를 참조하는 다른 방법 중 하나!
  
  & [주소연산자, ampersand] : 이가 피연산자인 변수의 메모리 주소를 반환하는 주소연산자 | &aa -> 변수 aa의 주소값을 반환. 실제 주소값은 4바이트 크기의 양의 정수
  
  포인터 변수 : 변수가 저장되는 곳의 주소값을 저장하는 변수 / 변수의 주소값은 반드시 포인터 변수에 저장해야 의미 있다. 
  | 선언방법 : 포인터 변수 선언에서 자료형과 표인터 변수 이름 사이에 연산자 *를 삽입하여 선언(int *P -> int포인터 P / 변수 P는 정수 int를 저장하는 일반변수의 주소를 저장하는 포인터 변수이자 포인터
  
  /*일반변수와 포인터 변수의 차이
  int data =100; // 변수data는 정수를 저장하는 "일반변수"
  int *p;   //변수p는 정수 int를 저장하는 일반변수의 주소를 저장하는 "포인터 변수"
  p=&data;  //포인터 p는 이제 data를 가르키므로-data주소값을 갖는다.
  */
*/

/*
  간접연산자*(indrection operator) : 포인터 변수가 갖는 주소로 그 주소의 원래 변수를 참조하기 위해 이용되는 연산자.
  
  직접참조(direct access) : 변수 int data 자체를 사용해 자신을 참조하는 방식
  간접참조(indirect access) : int *p를 이용해서 data를 참조하는 방식
*/

/*
  명시적 형변환 : 포인터 변수는 동일한 자료형끼리만 대입이 가능하며 다를 경우 오류가 발생 | 그러기에 명시적으로 형변환을 해주어야 한다. 
  -> ex] int v= 0x616;
         int *p=&v;
         char *pc=(char *) &v;
         
  다중 포인터와 증감 연산자의 활용 
 */
